# -*- coding: utf-8 -*-
"""potential_field.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bnuOtINYa21Ndx1enttt1HVjJklr3SGN
"""

import cv2
import numpy as np
import heapq as hq
import math
import time
# from google.colab.patches import cv2_imshow

canvas = np.ones((300,600,3))*255   # creating a frame for video generation
obstacle_set = set()             # set to store the obstacle points
obstacle_list = []               # list to store the obstacle points in order for videp

c2c_node_grid = [[float('inf')] * 300 for _ in range(600)]       # create a 2D array for storing cost to come
tc_node_grid = [[float('inf')] * 300 for _ in range(600)]        # create a 2D array for storing cost to come
closed_set = set()               # set to store the value of visited and closed points
closed_list = []

T = 1

'''
Loop to define the obstacle points in the map
'''
for y in range(300):                                       # loop to define the obstacle points : x
    for x in range(600):                                  # loop to define the obstacle points : y
        if (0<=y<=T):                                      # points in the bottom boundary
            obstacle_set.add((x,y))                        # add the points to the obstacle set
            obstacle_list.append((x,y))                    # add the points to the obstacle list
            c2c_node_grid[x][y] = -1                       # mark the points in the cost to come grid with -1
            tc_node_grid[x][y] = -1                        # mark the points in the total cost grid with -1
        elif (300-T<=y<300):                               # points in the top boundary
            obstacle_set.add((x,y))                        # add the points to the obstacle set
            obstacle_list.append((x,y))                    # add the points to the obstacle list
            c2c_node_grid[x][y] = -1                       # mark the points in the cost to come grid with -1
            tc_node_grid[x][y] = -1                        # mark the points in the total cost grid with -1
        # Points in the Circle shaped obstacle
        if ((x-112)**2 + (y-242.5)**2 <= (40+T)**2):
            obstacle_set.add((x,y))                        # add the points to the obstacle set
            obstacle_list.append((x,y))                    # add the points to the obstacle list
            c2c_node_grid[x][y] = -1                       # mark the points in the cost to come grid with -1
            tc_node_grid[x][y] = -1                        # mark the points in the total cost grid with -1
        # Points in the Circle shaped obstacle
        elif ((x-263)**2 + (y-90)**2 <= (70+T)**2):
            obstacle_set.add((x,y))                        # add the points to the obstacle set
            obstacle_list.append((x,y))                    # add the points to the obstacle list
            c2c_node_grid[x][y] = -1                       # mark the points in the cost to come grid with -1
            tc_node_grid[x][y] = -1                        # mark the points in the total cost grid with -1
        # Points in the Circle shaped obstacle
        elif ((x-445)**2 + (y-220)**2 <= (37.5+T)**2):
            obstacle_set.add((x,y))                        # add the points to the obstacle set
            obstacle_list.append((x,y))                    # add the points to the obstacle list
            c2c_node_grid[x][y] = -1                       # mark the points in the cost to come grid with -1
            tc_node_grid[x][y] = -1                        # mark the points in the total cost grid with -1


# Mark the obstacle points in the frame, including points after bloating
for point in obstacle_list:                            # loop to mark the obstacle points
    canvas[point[1],point[0]] = [255, 0, 0]            # mark the obstacle points with blue color

START_X = 0.0
START_Y = 150.0
GOAL_X = 600.0
GOAL_Y = 150.0

start = np.array([START_X, START_Y])
goal = np.array([GOAL_X, GOAL_Y])

Q_ROBOT = -1
Q_OBSTACLE = -1
Q_GOAL = 100

current_node = start

W1 = 7000
W2 = 1

goal_reached = False

while(not goal_reached):
    f_obs = np.array([0.0, 0.0])
    x = round(current_node[0])
    y = round(current_node[1])
    cv2.circle(canvas, (x,y), 3, (0, 0 ,255), -1)

    goal_vector = current_node - goal
    d1 = np.linalg.norm(goal_vector)

    f_mag_goal = W1 * Q_ROBOT * Q_GOAL/(d1**2)
    f_goal = f_mag_goal * (goal_vector/d1)

    if d1<=5:
        print("GOAL REACHED")
        goal_reached = True
        break

    for point in obstacle_list:
        obs_point = np.array([point[0], point[1]])
        obs_vector = current_node - obs_point
        d2 = np.linalg.norm(obs_vector)
        f_mag_obs = W2*Q_ROBOT*Q_OBSTACLE/(d2**2)
        f_obs += f_mag_obs * (obs_vector/d2)

    f = f_goal + f_obs

    current_node += (f*10/np.linalg.norm(f))

canvas_flipped = cv2.flip(canvas,0)
cv2.imshow("Potential Field Path Planning", canvas_flipped)
cv2.waitKey(0)
cv2.destroyAllWindows()